<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serial Checker Download</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body class="dark-theme">
    <div class="animated-bg">
        <canvas id="bg-canvas"></canvas>
    </div>
    <header>
        <h1 class="fade-in">Download the Serial Checker Tool</h1>
        <p class="animated-text">
            Instantly validate your serials and scan for active Anti-Cheats with our advanced Serial Checker & Anti-Cheat Scanner.
        </p>
    </header>
    <main>
        <section class="downloads-section slide-up">
            <div class="downloads-header">
                <h2>Available Downloads</h2>
            </div>
            <ul class="downloads-list center-list">
                <li>
                    <a href="downloads\Serial Checker.zip" download class="download-link">
                        <span class="download-icon">â¬‡</span> Serial Checker + Anti-Cheat Scanner
                    </a>
                </li>
            </ul>
            <p class="copyright">
                &copy; 2025 Serial Checker. All rights reserved.
            </p>
        </section>
    </main>
    <script>
        // Flowing colorful ribbons background (no mouse interaction, rounded edges)
        const canvas = document.getElementById('bg-canvas');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        });

        // Ribbons data
        const ribbons = [];
        const ribbonCount = 5;
        for (let i = 0; i < ribbonCount; i++) {
            let hue = Math.floor(Math.random() * 360);
            ribbons.push({
                points: Array.from({length: 22}, (_, j) => ({
                    x: (width / 20) * j,
                    y: height/2 + Math.sin(j/2 + i) * 60 + (i-2)*60,
                    vy: 0
                })),
                hue: hue,
                speed: 0.12 + Math.random() * 0.08,
                offset: Math.random() * 1000
            });
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            ribbons.forEach((ribbon, idx) => {
                ctx.save();
                ctx.beginPath();
                ribbon.points.forEach((pt, i) => {
                    // Animate the ribbon with rounded edges
                    let targetY = height/2 + Math.sin(i/2 + idx + performance.now()/1800 + ribbon.offset) * (80 + idx*18);

                    // Smoothly move toward targetY
                    pt.vy += (targetY - pt.y) * 0.08;
                    pt.vy *= 0.78;
                    pt.y += pt.vy;

                    if (i === 0) ctx.moveTo(pt.x, pt.y);
                    else ctx.lineTo(pt.x, pt.y);
                });

                // Rounded edges for the ribbon
                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                // Ribbon gradient
                let grad = ctx.createLinearGradient(0, 0, width, height);
                grad.addColorStop(0, `hsla(${ribbon.hue}, 90%, 65%, 0.55)`);
                grad.addColorStop(1, `hsla(${(ribbon.hue+60)%360}, 90%, 55%, 0.45)`);
                ctx.strokeStyle = grad;
                ctx.lineWidth = 22 - idx*3;
                ctx.shadowColor = `hsla(${ribbon.hue}, 90%, 60%, 0.22)`;
                ctx.shadowBlur = 32 - idx*4;
                ctx.globalAlpha = 0.7 - idx*0.09;
                ctx.stroke();
                ctx.restore();
            });

            ctx.globalAlpha = 1;
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>